import random
from Proverka import *

def z1():
    def qsort(mass):  # метод Хоара
        if len(mass) <= 1:  # если в массиве один или нет элементов, то сортировка заканчивается
            return mass  # возврат первоначального массива
        else:
            q = random.choice(mass)  # выбор рандомного числа, который будет опорным
        l_mass = []  # массив для элементов меньше опорного
        e_mass = [q] * mass.count(q)  # массив, в котором находятся опорный и равные ему числа, если такие существуют
        r_mass = []  # массив для элементов больше опорного
        for n in mass:  # сортировка элементов по массивам
            if n > q:
                r_mass.append(n)
            elif n < q:
                l_mass.append(n)
        return qsort(l_mass) + e_mass + qsort(r_mass)  # возвращение отсортированного массива

    print('==========================\n| Лабораторная работа №2 |\n==========================\n[Метод Хоара для двумерного массива]\nВведите кол-во строк в массиве')
    a = prov_z1()
    print('Введите кол-во столбцов в массиве')
    b = prov_z1()
    mass = [[0] * b for i in range(a)]
    for a1 in range(a):
        for b1 in range(b):
            mass[a1][b1] = random.randint(-100,100)
    print('Входной массив:')
    for i in range(len(mass)):
        print(mass[i])

    for j in range(b):
        A = []
        for i in range(len(mass)):
            ch = mass[i][j]
            A.append(ch)
        A = qsort(A)
        for i in range(len(mass)):
            mass[i][j] = A[i]

    print('Конечный массив:')
    for i in range(len(mass)):
        print(mass[i])
    return ('=====================\n    КОНЕЦ ЗАДАНИЯ    \n=====================')

def z2():

    def msort(mass):
        if len(mass) > 1:
            M = len(mass) // 2  # середина массив
            L = mass[:M]  # деление массива на левую и праву половины
            R = mass[M:]

            msort(R)  # рекурсивная сортировка двух половин до тех пор, пока их длина не будет равна 1
            msort(L)

            i = j = k = 0  # i — индекс списка L, j — индекс списка R, k — индекс исходного списка mass, в который нужно вставить все числа по порядку.
            while i < len(R) and j < len(L):  # объдинение половин в один лист с сортировкой
                if L[j] > R[i]:
                    mass[k] = R[i]
                    i += 1
                else:
                    mass[k] = L[j]
                    j += 1
                k += 1

            while i < len(R):  # добавление остатков листа в конец списка
                mass[k] = R[i]
                i += 1
                k += 1

            while j < len(L):  # добавление остатков листа в конец списка
                mass[k] = L[j]
                j += 1
                k += 1
        return mass

    print('==========================\n| Лабораторная работа №2 |\n==========================\nВведите кол-во элементов в одномерном массиве:')
    a = prov_z1()
    arr = []
    for i in range(a):
        arr.append(random.randint(-100, 100))

    print('Исходный массив: ', arr)
    arr = msort(arr)
    print('Конечный массив: ', arr)
    return ('=====================\n    КОНЕЦ ЗАДАНИЯ    \n=====================')

def z3():

    def bin_poisk(mass, znach):
        L = 0  # первый элемент массива
        R = len(mass) - 1  # последний элемент массива

        while L <= R:
            mid = int((L + R) / 2)  # нахождение среднего числа выделенного диапозона
            if (znach < mass[mid]):  # уменьшаем диапозон нахождения
                R = mid - 1  # диапозон будет в первой половине прошлого диапозона нахождения, т.е. слева от среднего числа
            elif (znach > mass[mid]):
                L = mid + 1  # диапозон будет во второй половине прошлого диапозона нахождения, т.е. справа от среднего числа
            else:  # если число равно среднему значению, то выводим результат => программа завершается
                return mid
        return ('Число не найдено!')  # если L > R, то числа нет в массиве, следовательно индекс не будет найден
    print('==========================\n| Лабораторная работа №2 |\n==========================\nВведите кол-во элементов в одномерном массиве:')
    n = prov_Z()
    mass = []
    for i in range(n):
        mass.append(random.randint(-100,100))
    mass.sort()
    print('Исходный массив: ', mass)

    print('===Бинарный поиск===')
    print('Введите число, индекс которого нужно найти: ')
    chislo = prov_Z()
    print('Индекс числа:', bin_poisk(mass, chislo))
    return ('=====================\n    КОНЕЦ ЗАДАНИЯ    \n=====================')